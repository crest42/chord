/**
 * @file chord.h
 * @author Robin LÃ¶sch
 * @date 18 Apr 2018
 * @brief Function and type definitions for the chord protocoll
 *
 * @see http://nms.csail.mit.edu/papers/chord.pdf
 * @see https://pdos.csail.mit.edu/papers/ton:chord/paper-ton.pdf
 */
#ifndef _LIBCHORD_H
#define _LIBCHORD_H
#include <arpa/inet.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#ifdef RIOT
#include "net/sock/udp.h"
#define TIMEOUT_DEF (2*US_PER_SEC)
#define TIMEOUT(y) (y*US_PER_SEC)
#else
#include <sys/socket.h>
#define TIMEOUT (2)
#endif

enum log_level
{
  OFF = 0x0,
  FATAL = 0x1,
  ERROR = 0x3,
  WARN = 0x7,
  INFO = 0xf,
  DEBUG = 0x1f,
  TRACE = 0x3f,
  ALL = 0xff
};

/** Defines if DEBUG Function and macros should be enabled. */
#ifdef DEBUG_ENABLE
#include <errno.h>
#include <stdio.h>

void
debug_printf(unsigned long t,
             const char* fname,
             enum log_level level,
             const char* format,
             ...);
char*
msg_to_string(int msg);
#define DEBUG(level, ...)                                                      \
  debug_printf((unsigned long)time(NULL), __func__, level, __VA_ARGS__)
#else
#define DEBUG(...)                                                             \
  {}
#define DEBUG_LEVEL OFF
#endif

typedef uint32_t nodeid_t;

#ifdef RIOT
#define _getpid() thread_getpid()
#else
#include <sys/syscall.h>
#define _getpid() (int)syscall(__NR_gettid)
#endif

/** Size of the hash digest which gets generated by the hashs functions. 20 is
 * the digest size oh sha1.
 */
#define HASH_DIGEST_SIZE 20
#define CHORD_RING_BITS (16)
#define FINGERTABLE_SIZE CHORD_RING_BITS
#define SUCCESSORLIST_SIZE CHORD_RING_BITS
#define CHORD_PORT (6667)
#define CHORD_TREE_CHILDS (2)
#define CHORD_TREE_ROOT (CHORD_RING_SIZE/2)
#define CHORD_OK (0)
#define CHORD_ERR (-1)
#define CHORD_PERIODIC_SLEEP (2)
#define CHORD_RING_SIZE (1 << CHORD_RING_BITS)
#define CHORD_CHANGE_ID (true)
#define CHORD_CHANGE_INTERVAL (5)
#define CHORD_MSG_COMMAND_SLOT (0)
#define CHORD_CHILD_TIMEOUT (3)
#define CHORD_MSG_COMMAND_SIZE (sizeof(uint32_t))
#define CHORD_MSG_SRC_ID_SIZE (sizeof(uint32_t))
#define CHORD_MSG_SRC_ID_SLOT (CHORD_MSG_COMMAND_SLOT + CHORD_MSG_COMMAND_SIZE)
#define CHORD_MSG_DST_ID_SIZE (sizeof(uint32_t))
#define CHORD_MSG_DST_ID_SLOT (CHORD_MSG_SRC_ID_SLOT + CHORD_MSG_SRC_ID_SIZE)
#define CHORD_MSG_LENGTH_SIZE (sizeof(uint32_t))
#define CHORD_MSG_LENGTH_SLOT (CHORD_MSG_DST_ID_SLOT + CHORD_MSG_DST_ID_SIZE)
#define CHORD_HEADER_SIZE                                                      \
  (CHORD_MSG_COMMAND_SIZE + CHORD_MSG_LENGTH_SIZE + CHORD_MSG_DST_ID_SIZE +    \
   CHORD_MSG_SRC_ID_SIZE)
#define CHORD_MSG_MAX_CONTENT_SIZE (MAX_MSG_SIZE - CHORD_HEADER_SIZE)

#define MAX_MSG_SIZE 1200

/**
 * \brief Possible Message Types
 *
 * A Chord message always consists of a header and a payload
 * The First sizeof(msg_type) bytes in our header defined which type our message
 * has
 */
enum msg_type
{
  MSG_TYPE_CHORD_ERR = -1, /*!< Error return type for failed requests */
  MSG_TYPE_NULL = 0,
  MSG_TYPE_FIND_SUCCESSOR = 1,           /*!< FIND_SUCCESSOR for given id */
  MSG_TYPE_FIND_SUCCESSOR_RESP = 2,      /*!< Response to FIND_SUCCESSOR */
  MSG_TYPE_FIND_SUCCESSOR_RESP_NEXT = 3, /*!< Next node we need to ask  */
  MSG_TYPE_GET_PREDECESSOR = 4,      /*!< GET_PREDECESSOR of the target node*/
  MSG_TYPE_GET_PREDECESSOR_RESP = 5, /*!< Response to GET_PREDECESSOR */
  MSG_TYPE_GET_PREDECESSOR_RESP_NULL = 6, /*!< NULL Response to GET_PRE */
  MSG_TYPE_GET_SUCCESSOR = 7,
  MSG_TYPE_GET_SUCCESSOR_RESP = 8,
  MSG_TYPE_PING = 9, /*!< Check if node is alive */
  MSG_TYPE_PONG = 10,
  MSG_TYPE_NOTIFY = 11,  /*!< Notify successor that we may be the predecessor */
  MSG_TYPE_NO_WAIT = 12, /*!< Dummy Type which indicated one-shot */
  MSG_TYPE_COPY_SUCCESSORLIST = 13,      /*!< Request to copy successorlist */
  MSG_TYPE_COPY_SUCCESSORLIST_RESP = 14, /*!< Response which holds suc. list */
  MSG_TYPE_EXIT = 15,
  MSG_TYPE_EXIT_ACK = 16,
  MSG_TYPE_GET = 17,
  MSG_TYPE_PUT = 18,
  MSG_TYPE_PUT_ACK = 19,
  MSG_TYPE_PUT_EFAIL = 20,
  MSG_TYPE_GET_RESP = 21,
  MSG_TYPE_GET_EFAIL = 22,
  MSG_TYPE_FIND_SUCCESSOR_LINEAR = 23,
  MSG_TYPE_REGISTER_CHILD = 24,
  MSG_TYPE_REGISTER_CHILD_OK = 25,
  MSG_TYPE_REGISTER_CHILD_EFULL = 26,
  MSG_TYPE_REGISTER_CHILD_EWRONG = 27,
  MSG_TYPE_REGISTER_CHILD_REDIRECT = 28,
  MSG_TYPE_REFRESH_CHILD = 29,
  MSG_TYPE_REFRESH_CHILD_OK = 30,
  MSG_TYPE_REFRESH_CHILD_REDIRECT = 31,
  MSG_TYPE_GET_SUCCESSORLIST_ID = 32,
  MSG_TYPE_GET_SUCCESSORLIST_ID_RESP = 33,
  MSG_TYPE_GET_SUCCESSORLIST_ID_EFAIL = 34,
  MSG_TYPE_SYNC = 35,
  MSG_TYPE_SYNC_REQ_RESP = 36,
  MSG_TYPE_SYNC_REQ_FETCH = 37,
  MSG_TYPE_SYNC_REQ_FETCH_OK = 38,
  MSG_TYPE_PUSH = 39,
};
typedef enum msg_type chord_msg_t;

/**
 * \brief A definition of a node
 *
 * A Node is a member of the ring
 */

struct node
{
  nodeid_t id; /*!< Id of the node. The node id is the hashed ipv6 address of
                  the node modulo the ring size */
  uint32_t size;
  uint32_t used;
  struct in6_addr addr;
};

struct node_additional {
  struct node* successor;   /*!< Pointer to our successor node. */
  struct node* predecessor; /*!< Pointer to our predecessor node */
};

#ifdef RIOT
struct socket_wrapper {
  sock_udp_t sock;
  sock_udp_ep_t remote;
  sock_udp_ep_t local;
  bool any;
};
#else
struct socket_wrapper {
  int sock;
  struct sockaddr_in6 remote;
};
#endif

struct aggregate{
  uint32_t nodes;
  uint32_t available;
  uint32_t used;
};

struct child
{
  nodeid_t parent;
  nodeid_t child;
  int i;
  time_t t;
  struct node parent_suc;
  struct aggregate aggregation;
};

struct childs
{
  struct child child[CHORD_TREE_CHILDS];
};

/**
 * \brief An Entry in our fingertable.
 *
 * The Fingertable is a "shortcut" through the ring, which allows us to query
 * nodes in O(log n) instead of O(n)
 */
struct fingertable_entry
{
  nodeid_t start;    /*!< Startpoint of the finger. */
  nodeid_t interval; /*!< Size of the Interval. End is start+interval */
  struct node node;  /*!< Pointer to a node who is the successor of end */
};

typedef int (*chord_callback)(chord_msg_t,
                              unsigned char*,
                              nodeid_t,
                              struct socket_wrapper *,
                              size_t);

typedef int(*chord_periodic_hook)(void *);

struct hooks {
  chord_periodic_hook periodic_hook;
  void* periodic_data;
};

int
handle_ping(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);

int
handle_exit(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);
int
handle_find_successor(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);

int
handle_get_predecessor(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);
int
handle_notify(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);

int
handle_register_child(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);

int
handle_refresh_child(chord_msg_t type,
            unsigned char* data,
            nodeid_t src,
            struct socket_wrapper *sock,
            size_t msg_size);

struct chord_callbacks
{
  chord_callback ping_handler;
  chord_callback exit_handler;
  chord_callback find_successor_handler;
  chord_callback get_predecessor_handler;
  chord_callback notify_handler;
  chord_callback put_handler;
  chord_callback get_handler;
  chord_callback register_child_handler;
  chord_callback refresh_child_handler;
  chord_callback sync_handler;
  chord_callback sync_fetch_handler;
};

struct chord_callbacks*
get_callbacks(void);

int
chord_send_block_and_wait(struct node* target,
                          unsigned char* msg,
                          size_t size,
                          chord_msg_t wait,
                          /*@null out@*/  unsigned char* buf,
                          size_t bufsize,
                          /*@null@*/ size_t *ret_size);

/**
 * \brief Set up a node struct from a given address
 *
 * @param address Target ipv6 address of the node we want to create
 * @param node Return parameter where the node is saved needs to be pre
 * allocated
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
create_node(char* address, struct node* node);

struct hooks*
get_hooks(void);
struct aggregate *get_stats(void);
struct node*
get_own_node(void);
struct node*
get_successor(void);

struct node*
get_predecessor(void);
/*@null@*/ struct node*
closest_preceeding_node(nodeid_t id);

/**
 * \brief Returns fingertable
 *
 * @return fingertable_entry pointer to first fingertable entry
 */
struct fingertable_entry*
get_fingertable(void);

/**
 * \brief Returns successorlist
 *
 * @return Return pointer to first successorlist entry
 */
struct node*
get_successorlist(void);

/**
 * \brief Finds and returns the successor of a given Chord ring
 *
 * This functions walks around our ring until it finds the successor of a given
 * id. A successor if a id is the next node which has a id greater or equal the
 * provided id
 *
 * @param node Node to ask for the successor
 * @param Return parameter where to successor of @id is provided. Needs to be
 * allocated
 * @param id The id for which we need the successor
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
find_successor(struct node* node, struct node* ret, nodeid_t id);

/**
 * \brief Generates a hash. Implementation speicific
 *
 * This function needs to be implemented by the Application. The Hash function
 * can be any function which results are distributed evenly
 *
 * @param out Provided buffer which holds the generated hash
 * @param in Buffer which holds the data to be HASH_DIGEST_SIZE
 * @in_size Size of the input data
 * @out_size Size of the resulting hash in bytes
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
hash(/*@out@*/ unsigned char* out,
     const unsigned char* in,
     size_t in_size,
     size_t out_size);
uint32_t
get_mod_of_hash(unsigned char* hash, int modulo);
/**
 * \brief Init the libary
 *
 * This function set up the chord ring.
 * E. g. generates the nodes which belongs to the application and init data
 * structures etc.
 *
 * @param Node_addr Node addr to listen
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
init_chord(const char* addr);

int
chord_start(void);

/**
 * \brief Add a Node to out Chord Ring
 *
 * This functions add a node to our Chord ring
 *
 * @param node The node to add. If node is NULL we set up a new Ring.
 * Otherwise we try to join to the node provided
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
add_node(struct node* node);

/**
 * \brief Join a node into a chord network.
 *
 *  This function try to send a chord join to a known member in the ring.
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
join(struct node* target);

/**
 * \brief Notify a node n' that we now consider it our successor.
 * This is needed because n' may want to select us as his new predecessor.
 *
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
int
notify(struct node* target);

/**
 * \brief  Function which needs to be invoked by a thread answer requests from
 * other nodes
 *
 * Answer messages like get_successor and checks ring on incomming notify
 * messages
 *
 * @param n Own node which is setup by init_chord and can be fetched using
 * @get_own_node
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
/*@null@*/ void*
thread_wait_for_msg(void* n);

/**
 * \brief  Function which needs to be invoked by a thread to stabilize the
 * ring
 *
 * Stabilize the ring as needed by the chord protocoll and then sleeps
 * CHORD_PERIODIC_SLEEP seconds
 *
 * @param n Own node which is setup by init_chord and can be fetched
 * using @get_own_node
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
/*@null@*/ void*
thread_periodic(void* n);

/**
 * \brief Print informations about a node, like it's id, successor and
 * predecessor
 *
 * @param verbose also print successorlist and fingertable
 * @return CHORD_OK if everything is fine CHORD_ERR otherwise
 */
void
debug_print_node(struct node* node, bool verbose);

/**
 * \brief Finds out if a node is considered as null
 *
 * @param node node to check
 * @return true is node id null, false otherwise
 */
bool
node_is_null(struct node* node);

/**
 * \brief Sends data non blocking over a socket
 *
 * @param msg msg to send
 * @param size size of the message
 * @param s socket wrapper
 *
 * @return CHORD_OK on successful send, CHORD_ERR otherwise
 */
int
chord_send_nonblock_sock(unsigned char* msg,
                         size_t size,
                         struct socket_wrapper* s);
/**
 * \brief Removes a failing node out of local data structures
 *
 * @param id id of the failing node
 * @return CHORD_OK is removing was successful, CHORD_ERR otherwise
 */
int
remove_dead_node(nodeid_t id);

/**
 * \brief Creates a copy of a node
 *
 * @param node node to copy
 * @param copy target data structure
 *
 * @return CHORD_OK is copy was successful, CHORD_ERR otherwise
 */
int
copy_node(struct node* node, struct node* copy);

/**
 * \brief checks if an id lies between an interval of two nodes
 *
 * check if id is element of [first,second)
 *
 * @return true if id is in interval, false if id is outside of interval
 */
bool
in_interval(struct node* first, struct node* second, nodeid_t id);
bool
in_interval_id(nodeid_t start, nodeid_t end, nodeid_t test);

/**
 * \brief Returns the IDs of all nodes in the successorlist of a node
 *
 * @param target node to ask
 * @param id array of SUCCESSORLIST_SIZE nodeid_t elements to return the ids
 *
 * @return CHORD_OK on success, CHORD_ERR otherwise
 */
int
get_successorlist_id(struct node* target, nodeid_t* id);

void
chord_mutex_lock(void);

void
chord_mutex_unlock(void);
#endif
